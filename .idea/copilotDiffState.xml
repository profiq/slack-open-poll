<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/functions/src/tests/openButtonHandler.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/functions/src/tests/openButtonHandler.test.ts" />
              <option name="originalContent" value="import { describe, it, expect, vi, beforeEach } from 'vitest';&#10;import { handleOpenButton } from '../../src/handlers/openButtonHandler';&#10;import { App, BlockAction, ButtonAction, SlackActionMiddlewareArgs } from '@slack/bolt';&#10;&#10;describe('handleOpenButton', () =&gt; {&#10;  const ack = vi.fn();&#10;  const viewsOpen = vi.fn();&#10;  const triggerId = 'trigger_123';&#10;  const pollId = 'poll_abc';&#10;&#10;  const client = {&#10;    views: {&#10;      open: viewsOpen,&#10;    },&#10;  } as unknown as App['client'];&#10;&#10;  const body = {&#10;    trigger_id: triggerId,&#10;  };&#10;&#10;  const action: ButtonAction = {&#10;    action_id: 'open_button',&#10;    type: 'button',&#10;    value: pollId,&#10;    block_id: 'block_1',&#10;    text: { type: 'plain_text', text: 'Open' },&#10;    action_ts: '123456789.000000',&#10;  };&#10;&#10;  const args = {&#10;    ack,&#10;    body,&#10;    client,&#10;    action,&#10;  } as unknown as SlackActionMiddlewareArgs&lt;BlockAction&gt; &amp; { client: App['client'] };&#10;&#10;  beforeEach(() =&gt; {&#10;    vi.clearAllMocks();&#10;  });&#10;&#10;  it('acknowledges the button click and opens a modal', async () =&gt; {&#10;    await handleOpenButton(args);&#10;&#10;    expect(ack).toHaveBeenCalledOnce();&#10;    expect(viewsOpen).toHaveBeenCalledWith({&#10;      trigger_id: triggerId,&#10;      view: expect.objectContaining({&#10;        type: 'modal',&#10;        callback_id: 'poll_modal',&#10;        title: { type: 'plain_text', text: 'Poll Options' },&#10;        close: { type: 'plain_text', text: 'Close' },&#10;        blocks: expect.arrayContaining([&#10;          expect.objectContaining({&#10;            type: 'actions',&#10;            elements: expect.arrayContaining([&#10;              expect.objectContaining({&#10;                type: 'button',&#10;                action_id: 'your_votes',&#10;                value: pollId,&#10;              }),&#10;              expect.objectContaining({&#10;                type: 'button',&#10;                action_id: 'poll_settings',&#10;                value: pollId,&#10;              }),&#10;            ]),&#10;          }),&#10;        ]),&#10;      }),&#10;    });&#10;  });&#10;&#10;  it('includes the correct value in both buttons', async () =&gt; {&#10;    await handleOpenButton(args);&#10;&#10;    const viewArg = viewsOpen.mock.calls[0][0].view;&#10;&#10;    const buttonElements = viewArg.blocks[0].elements;&#10;    const values = buttonElements.map((el: ButtonAction) =&gt; el.value);&#10;&#10;    expect(values).toEqual([pollId, pollId]);&#10;  });&#10;&#10;  it('handles multiple opens with different pollIds correctly', async () =&gt; {&#10;    const pollIds = ['poll_1', 'poll_2'];&#10;&#10;    for (const id of pollIds) {&#10;      const dynamicArgs = {&#10;        ...args,&#10;        action: { ...args.action, value: id },&#10;      };&#10;      await handleOpenButton(dynamicArgs);&#10;&#10;      const viewArg = viewsOpen.mock.calls.at(-1)?.[0].view;&#10;      const values = viewArg.blocks[0].elements.map((el: ButtonAction) =&gt; el.value);&#10;&#10;      expect(values).toEqual([id, id]);&#10;    }&#10;&#10;    expect(ack).toHaveBeenCalledTimes(2);&#10;  });&#10;&#10;  it('throws an error if trigger_id is missing and does not call views.open', async () =&gt; {&#10;    const badArgs = {&#10;      ...args,&#10;      body: {},&#10;    } as typeof args;&#10;&#10;    await expect(handleOpenButton(badArgs)).rejects.toThrow('Missing trigger id');&#10;&#10;    expect(viewsOpen).not.toHaveBeenCalled();&#10;    expect(ack).toHaveBeenCalledOnce();&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { describe, it, expect, vi, beforeEach } from 'vitest';&#10;import { handleOpenButton } from '../../src/handlers/openButtonHandler';&#10;import { App, BlockAction, ButtonAction, SlackActionMiddlewareArgs } from '@slack/bolt';&#10;&#10;describe('handleOpenButton', () =&gt; {&#10;  const ack = vi.fn();&#10;  const viewsOpen = vi.fn();&#10;  const triggerId = 'trigger_123';&#10;  const pollId = 'poll_abc';&#10;&#10;  const client = {&#10;    views: {&#10;      open: viewsOpen,&#10;    },&#10;  } as unknown as App['client'];&#10;&#10;  const body = {&#10;    trigger_id: triggerId,&#10;  };&#10;&#10;  const action: ButtonAction = {&#10;    action_id: 'open_button',&#10;    type: 'button',&#10;    value: pollId,&#10;    block_id: 'block_1',&#10;    text: { type: 'plain_text', text: 'Open' },&#10;    action_ts: '123456789.000000',&#10;  };&#10;&#10;  const args = {&#10;    ack,&#10;    body,&#10;    client,&#10;    action,&#10;  } as unknown as SlackActionMiddlewareArgs&lt;BlockAction&gt; &amp; { client: App['client'] };&#10;&#10;  beforeEach(() =&gt; {&#10;    vi.clearAllMocks();&#10;  });&#10;&#10;  it('acknowledges the button click and opens a modal', async () =&gt; {&#10;    await handleOpenButton(args);&#10;&#10;    expect(ack).toHaveBeenCalledOnce();&#10;    expect(viewsOpen).toHaveBeenCalledWith({&#10;      trigger_id: triggerId,&#10;      view: expect.objectContaining({&#10;        type: 'modal',&#10;        callback_id: 'poll_modal',&#10;        title: { type: 'plain_text', text: 'Poll Options' },&#10;        close: { type: 'plain_text', text: 'Close' },&#10;        blocks: expect.arrayContaining([&#10;          expect.objectContaining({&#10;            type: 'actions',&#10;            elements: expect.arrayContaining([&#10;              expect.objectContaining({&#10;                type: 'button',&#10;                action_id: 'your_votes',&#10;                value: pollId,&#10;              }),&#10;              expect.objectContaining({&#10;                type: 'button',&#10;                action_id: 'poll_settings',&#10;                value: pollId,&#10;              }),&#10;            ]),&#10;          }),&#10;        ]),&#10;      }),&#10;    });&#10;  });&#10;&#10;  it('includes the correct value in both buttons', async () =&gt; {&#10;    await handleOpenButton(args);&#10;&#10;    const viewArg = viewsOpen.mock.calls[0][0].view;&#10;&#10;    const buttonElements = viewArg.blocks[0].elements;&#10;    const values = buttonElements.map((el: ButtonAction) =&gt; el.value);&#10;&#10;    expect(values).toEqual([pollId, pollId]);&#10;  });&#10;&#10;  it('handles multiple opens with different pollIds correctly', async () =&gt; {&#10;    const pollIds = ['poll_1', 'poll_2'];&#10;&#10;    for (const id of pollIds) {&#10;      const dynamicArgs = {&#10;        ...args,&#10;        action: { ...args.action, value: id },&#10;      };&#10;      await handleOpenButton(dynamicArgs);&#10;&#10;      const viewArg = viewsOpen.mock.calls.at(-1)?.[0].view;&#10;      const values = viewArg.blocks[0].elements.map((el: ButtonAction) =&gt; el.value);&#10;&#10;      expect(values).toEqual([id, id]);&#10;    }&#10;&#10;    expect(ack).toHaveBeenCalledTimes(2);&#10;  });&#10;&#10;  it('throws an error if trigger_id is missing and does not call views.open', async () =&gt; {&#10;    const badArgs = {&#10;      ...args,&#10;      body: {},&#10;    } as typeof args;&#10;&#10;    await expect(handleOpenButton(badArgs)).rejects.toThrow('Missing trigger id');&#10;&#10;    expect(viewsOpen).not.toHaveBeenCalled();&#10;    expect(ack).toHaveBeenCalledOnce();&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;open-poll&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;**OpenPoll** is an open-source Slack-integrated app that lets your team quickly create and run polls using a `/poll` command. Inspired by [Simple Poll](https://www.simplepoll.rocks/), OpenPoll is built in **TypeScript**, runs on **Firebase Cloud Functions**, and is fully customizable for self-hosting or development learning.&quot;,&#10;  &quot;main&quot;: &quot;index.js&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;husky&quot;: &quot;^9.1.7&quot;&#10;  },&#10;  &quot;scripts&quot;: {&#10;    &quot;prepare&quot;: &quot;husky&quot;&#10;  },&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;open-poll&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;**OpenPoll** is an open-source Slack-integrated app that lets your team quickly create and run polls using a `/poll` command. Inspired by [Simple Poll](https://www.simplepoll.rocks/), OpenPoll is built in **TypeScript**, runs on **Firebase Cloud Functions**, and is fully customizable for self-hosting or development learning.&quot;,&#10;  &quot;main&quot;: &quot;index.js&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;husky&quot;: &quot;^9.1.7&quot;&#10;  },&#10;  &quot;scripts&quot;: {&#10;    &quot;prepare&quot;: &quot;husky&quot;,&#10;    &quot;test&quot;: &quot;vitest run&quot;,&#10;    &quot;test:watch&quot;: &quot;vitest watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;vitest run --coverage&quot;&#10;  },&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>